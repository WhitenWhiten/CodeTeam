# roles/qa_agent.py
from __future__ import annotations
from typing import Dict, Any, List, Set
try:
    from metagpt.roles import Role
except ImportError:
    class Role:
        def __init__(self, name: str = ""):
            self.name = name
        def set_actions(self, actions): self._actions = actions
        def run(self, action_cls, **kwargs):
            action = None
            for a in self._actions:
                if isinstance(a, action_cls) or (a.__class__ is action_cls):
                    action = a
                    break
            if not action:
                action = action_cls()
            coro = action.run(**kwargs)
            if hasattr(coro, "__await__"):
                import asyncio
                return asyncio.get_event_loop().run_until_complete(coro)
            return coro

from actions.generate_tests import GenerateTestsAction
from actions.run_tests import RunTestsAction

class QAAgent(Role):
    def __init__(self, llm, repo_manager, runtime_adapter, event_bus, sds=None):
        super().__init__(name="QA")
        self.llm = llm
        self.repo = repo_manager
        self.adapter = runtime_adapter
        self.event_bus = event_bus
        self.sds = sds
        self.file_owner: Dict[str, str] = {}
        if sds:
            for a in sds.dev_plan:
                for f in a.file_paths:
                    self.file_owner[f] = a.developer_id
        self.set_actions([GenerateTestsAction(llm=llm), RunTestsAction()])

    async def init_tests(self, sds_json: dict):
        res = await self.run(GenerateTestsAction, sds=sds_json, llm=self.llm)
        for fpath, content in res["tests"].items():
            self.repo.write_file(fpath, content, agent_id="QA")
        self.repo.commit_all("test: initial tests generated by QA")
        self.run_command = res["run_command"]

    def _map_failures(self, failures: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        suggestions = []
        # 已知的源文件集合
        src_files: Set[str] = set(self.file_owner.keys())
        for fail in failures:
            fp = fail.get("file_path", "")
            stack = fail.get("stack", "")
            # 简单从堆栈中找匹配到的源文件路径
            target = None
            for line in stack.splitlines():
                for sf in src_files:
                    if sf in line:
                        target = sf
                        break
                if target:
                    break
            if not target:
                # 若直接报告的文件就在源文件中
                if fp in src_files:
                    target = fp
            if not target:
                # fallback: 把同一轮全部分发（保守，但确保推进）
                for sf in src_files:
                    suggestions.append({"dev_id": self.file_owner[sf], "file_path": sf, "issues": fail})
            else:
                suggestions.append({"dev_id": self.file_owner[target], "file_path": target, "issues": fail})
        return suggestions

    async def run_and_feedback(self):
        result = await self.run(RunTestsAction, repo_root=str(self.repo.root), run_command=self.run_command, runtime_adapter=self.adapter)
        fix_suggestions = self._map_failures(result.get("failures", []))
        result["fix_suggestions"] = fix_suggestions
        self.event_bus.emit("qa_result", result)
        return result
